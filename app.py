# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FY7JEybxb9trqUV_hgehDOUQJlg0nA7z
"""

import streamlit as st
import numpy as np
from tensorflow.keras.models import load_model
from gensim.models import Word2Vec
from sklearn.preprocessing import Normalizer
import os

# Load Pre-trained Models
@st.cache_resource
def load_lstm_model():
    return load_model('final_lstm_model.h5')

@st.cache_resource
def load_word2vec_model():
    return Word2Vec.load('best_word2vec_phishing_opt.bin')

lstm_model = load_lstm_model()
word2vec_model = load_word2vec_model()

# Load Normalizer
normalizer = Normalizer(norm='l2')

# Helper Functions
def extract_features(url):
    """Extract handcrafted features from the URL."""
    length = len(url)
    subdomains = url.count('.') - 1
    special_chars = sum(1 for char in url if not char.isalnum())
    numbers = sum(1 for char in url if char.isdigit())
    has_https = int(url.startswith('https'))

    try:
        domain_length = len(url.split('/')[2])
    except IndexError:
        domain_length = 0

    return np.array([length, subdomains, special_chars, numbers, has_https, domain_length])

def get_word2vec_vector(url):
    """Generate Word2Vec vector from the URL."""
    words = url.split('/')
    word_vectors = [word2vec_model.wv[word] for word in words if word in word2vec_model.wv]
    return np.mean(word_vectors, axis=0) if word_vectors else np.zeros(word2vec_model.vector_size)

def predict_url(url):
    """Make prediction for a given URL."""
    # Extract features
    handcrafted_features = extract_features(url)
    word2vec_vector = get_word2vec_vector(url)

    # Combine features
    combined_features = np.hstack((word2vec_vector, handcrafted_features))

    # Normalize features
    combined_features = normalizer.transform([combined_features])

    # Reshape for LSTM
    lstm_input = combined_features.reshape((1, 1, combined_features.shape[1]))

    # Predict
    prediction = lstm_model.predict(lstm_input)
    return prediction[0][0]

# Streamlit App Layout
st.title("Phishing URL Detection")
st.markdown("""
This application detects whether a given URL is **phishing** or **non-phishing**.
Enter a URL below to check its status.
""")

# Input URL
input_url = st.text_input("Enter a URL:")

if st.button("Check URL"):
    if input_url:
        # Predict
        prediction_score = predict_url(input_url)
        if prediction_score > 0.5:
            st.success(f"The URL is **Non-Phishing** with a confidence score of {prediction_score:.2f}.")
        else:
            st.error(f"The URL is **Phishing** with a confidence score of {1 - prediction_score:.2f}.")
    else:
        st.warning("Please enter a valid URL.")